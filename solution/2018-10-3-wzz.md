[TOC]

# 10/3 题解

## T1：UnderCity



此题的三种方法都比较经典，建议基础薄弱的同学都实现一遍。

### 方法一（部分分）

预处理两两之间的LCA，暴力枚举三个满足条件的点，求出它们的LCA，那么从LCA到根都会算上这三个点的贡献，用树上差分维护这个东西即可，复杂度$O(n^3)$



### 方法二

> 考虑到点数只有5000，我们只要在$nlogn$的时间内对每个子树去计算答案就能通过此题。出题人比较善良，放了这种方法通过。

- 问题变成有n个元素，每个元素有两维信息$(dep, val)$，我们需要求两维信息满足$dep_{x1}$ < $dep_{x2}$ , $dep_{x1} < dep_{x3} $，$val_{x1} > val_{x2} > val_{x3}$的 三元组$(x1,x2,x3)$的数量,

- 对于这种二维偏序问题，一般的处理思路是对某一维信息进行排序，另外一维信息用一个数据结构或者打标记去维护。

- 此题的限制比一般的二维偏序稍微复杂一丢丢, 先要考虑清楚对哪一维信息进行排序

  >- 如果对$val$升序或者降序排序,然后枚举$x1$来算有多少对满足条件的$(x2,x3)$,   那么现在我们要求dep值大于$dep_{x1}$的 而且val值小于$val_{x1}$, 有多少对val值不同的点，问题似乎丝毫没有简化，因为还是要考虑两维
  >
  >- 那么我们尝试着按照$dep$ 降序排序，然后对于相同dep的点一起处理,先询问,后插入,那么之前的$dep$都大于当前的$dep$，任意点对都满足第一个条件限制，我们只需专心解决有多少不同$val$值的点对小于当前$val$值这个子问题即可
  >
  > 

  <font color=#A52A2A size=4 face="黑体"> 最终问题： 对于每个前缀求前缀中有多少不同值的点对小于当前的值</font>



  直接算不同值的点对比较难，我们算总量减去小于当前val值的相同val值的点对即可，假设小于当前$val$有m种val值，那么就是求$c_1* （c_1 - 1）/ 2 + c_2*(c_2-1)/2 + ... + c_m*(c_m-1)/2$,  $c_i$表示第i种val值的出现次数，因此我们需要一个线段树$T$，以val值建值域线段树，维护区间每种值出现次数的平方和，以及次数的和，每插入一个val值相当于单点修改线段树，由于线段树的功能是单点修改，区间查询，因此线段树可以替换成树状数组来优化速度。

  复杂度：$O(n^2logn)$


### 方法三 

考虑利用子树的信息来合并，如果每个子树的答案都已经算好了，能否利用当前节点的子树维护的信息来得到当前节点的答案呢？

我们知道直接两两枚举两个子树的所有节点的复杂度是$O(n^2)$的, 因为这相当于在枚举树上所有的点对

如果我们可以暴力合并两个子树的信息来维护计算答案所需的信息，那么我们只需要自底向上一层层合并上来就可以了

具体说来,假设两个子树的节点分别保存在

$vector <int> a, b$

那么我们可以利用如下代码来暴力合并信息, $cnt[u]$表示其他兄弟子树中$dep$值大于u节点,而且val值小于u节点的节点数量, 合并好之后我们枚举当前子树以每个点作为$x_1$，算其他两个点的点对数量就是 $cnt[u] * (cnt[u] - 1) / 2$  , 但是这个会多算那些val值相同的的点对, 所以维护信息的时候还需要维护有多少对相同的val值小于当前的val值



```cpp
void Merge(vector<int> &a, const vector<int> &b) {
    for (int i = 0; i < (int)a.size(); ++i)
        for (int j = 0; j < (int)b.size(); ++j) {
            if (de[a[i]] < de[b[j]] && val[a[i]] > val[b[j]]) {
                ++cnt[a[i]];
                //nu[u][v]表示对u节点if条件满足的点中v值的出现次数
                //qu[u]表示val值小于val[u]的 值中相同val值的点对数量
                qu[a[i]] += nu[a[i]][val[b[j]]]++;
            }
            if (de[a[i]] > de[b[j]] && val[a[i]] < val[b[j]]) {
                ++cnt[b[j]];
                qu[b[j]] += nu[b[j]][val[a[i]]]++;
            }
        }
    a.insert(a.end(), b.begin(), b.end());
}
 

```



## T2:StromWind



首先这个题，暴力按照题意模拟可以拿到20分，只需要掌握如何求最长路算法。

最长路可能有很多个开头，多个结尾，方便起见，我们新建一个源点S向每个点连边，新建一个汇点T，所有点向T连边。

首先对于第二与第三种操作我们可以从S跑一边最长路预处理出F[i]表示S到i的最长路，然后从T点倒着跑一遍求出i到T的最长路G[i],那么必须经过x的答案为$F[x] + G[x] - 2$,必须经过第x条边的答案为$F[from] + G[to]  - 1$ , 假设第x条边为from->to

那么我们考虑第一种操作，不经过x点的最长路相当于最长路会横跨x，就是先经过拓扑序在x之前的一个点，然后再经过拓扑序在x之后的一个点，那么我们可以沿着拓扑序列扫描，边扫描边维护$F[from] + G[to] - 1$的最大值，from在x之间，to在x之后（拓扑序）

具体可以这么做：每到一个点u就删除以这个点为结束点的所有$F[pre_u]+G[u]-1$, 然后询问set中的最大值作为删除当前点的答案，然后插入以这个点为出发点的所有的 $F[u] + G[v] - 1$。